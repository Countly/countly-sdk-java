package ly.count.sdk.java.internal;

import java.util.Arrays;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicInteger;
import ly.count.sdk.java.Config;
import ly.count.sdk.java.Countly;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

@RunWith(JUnit4.class)
public class ModuleDeviceIdTests {

    @After
    public void stop() {
        Countly.instance().halt();
        SDKCore.testDummyModule = null;
    }

    @Before
    public void beforeTest() {
        TestUtils.createCleanTestState();
    }

    /**
     * Device ID acquisition process
     * Initializing the SDK with no custom ID, that should trigger ID generation
     * The acquired device ID should start with "CLY_"
     */
    @Test
    public void generatedDeviceId() {
        Countly.instance().init(TestUtils.getBaseConfig(null));
        validateDeviceIdIsSdkGenerated();
    }

    /**
     * Device ID acquisition process
     * Initializing the SDK with a custom ID, that should not trigger ID generation
     * The acquired device ID should not contain any "CLY_"
     */
    @Test
    public void customDeviceId() {
        Countly.instance().init(TestUtils.getBaseConfig(TestUtils.DEVICE_ID));
        validateDeviceIdDeveloperSupplied(TestUtils.DEVICE_ID);
    }

    /**
     * "changeWithMerge"
     * Validating that only one began session request is created and two device id change request for two
     * "changeWithMerge" calls with different ids
     * SDK must generate an id first, then should change with developer supplied two times
     */
    @Test
    public void changeWithMerge() {
        TestUtils.AtomicString deviceID = new TestUtils.AtomicString(TestUtils.DEVICE_ID);
        AtomicInteger callCount = initDummyModuleForDeviceIdChangedCallback(deviceID, false, DeviceIdType.DEVELOPER_SUPPLIED);
        Countly.instance().init(TestUtils.getConfigDeviceId(null)); // to create sdk generated device id
        setupView_Event_Session();
        Assert.assertEquals(1, TestUtils.getCurrentRQ().length); // began session request
        // validate began session request with generated id
        validateBeganSessionRequest();
        validateDeviceIdIsSdkGenerated(); // validate device id generated by the sdk

        String oldDeviceId = Countly.instance().deviceId().getID();
        Assert.assertEquals(0, callCount.get()); // validate "deviceIdChanged" callback not called

        Countly.instance().deviceId().changeWithMerge(deviceID.value); // TestUtils.DEVICE_ID
        Assert.assertEquals(1, callCount.get());
        validateDeviceIdWithMerge(oldDeviceId, 1, 2);

        deviceID.value += "1";
        Countly.instance().deviceId().changeWithMerge(deviceID.value); // TestUtils.DEVICE_ID + "1"
        Assert.assertEquals(2, callCount.get());
        validateDeviceIdWithMerge(TestUtils.DEVICE_ID, 2, 3);
    }

    /**
     * "changeWithoutMerge" with custom device id
     * Validating that new id set and callback is called, and existing events,
     * timed events and session must end, new session must begin
     */
    @Test
    public void changeWithoutMerge() {
        //why atomic string? Because changing it should also trigger dummy module callback asserts.
        //so it should be modifiable from outside
        TestUtils.AtomicString deviceID = new TestUtils.AtomicString(TestUtils.keysValues[0]);
        AtomicInteger callCount = initDummyModuleForDeviceIdChangedCallback(deviceID, true, DeviceIdType.DEVELOPER_SUPPLIED);
        Countly.instance().init(TestUtils.getConfigDeviceId(TestUtils.DEVICE_ID)); //custom id given
        setupView_Event_Session(); // setup view, event and session to simulate a device id change
        validateBeganSessionRequest(); // also validates rq size is 1

        validateDeviceIdDeveloperSupplied(TestUtils.DEVICE_ID);
        Assert.assertEquals(0, callCount.get());

        Countly.instance().deviceId().changeWithoutMerge(deviceID.value);
        Assert.assertEquals(1, callCount.get());
        validateDeviceIdWithoutMergeChange(4, TestUtils.DEVICE_ID); // there should be 2 began, 1 end, 1 events request
        TestUtils.flushCurrentRQ(); // clean current rq to test out new tests

        deviceID.value += "1"; //change device id
        Countly.instance().deviceId().changeWithoutMerge(deviceID.value);
        Assert.assertEquals(2, callCount.get());
        //if device id is not merged, then device id change request should not exist
        validateDeviceIdWithoutMergeChange(2, TestUtils.keysValues[0]); // additional 1 session end 1 session begin, no events because no events exist
    }

    /**
     * "changeWithMerge" with null device id
     * Validating that only one request added, and it should be a began session request, callback must not be called
     * SDK must generate an id first, calling with null given id should not trigger anything
     */
    @Test
    public void changeWithMerge_nullDeviceId() {
        AtomicInteger callCount = initDummyModuleForDeviceIdChangedCallback(null, false, DeviceIdType.SDK_GENERATED);
        Countly.instance().init(TestUtils.getConfigDeviceId(null)); // to create sdk generated device id
        setupView_Event_Session();

        validateDeviceIdIsSdkGenerated();
        Assert.assertEquals(0, callCount.get());

        Countly.instance().deviceId().changeWithMerge(null);
        Assert.assertEquals(0, callCount.get());// validate callback not called
        validateBeganSessionRequest(); // also validates rq size is 1
    }

    /**
     * "changeWithMerge" with empty device id
     * Validating that only one request added, and it should be a began session request, callback must not be called
     * SDK must generate an id first, calling with empty given id should not trigger anything
     */
    @Test
    public void changeWithMerge_emptyDeviceId() {
        AtomicInteger callCount = initDummyModuleForDeviceIdChangedCallback(new TestUtils.AtomicString(""), false, DeviceIdType.SDK_GENERATED);
        Countly.instance().init(TestUtils.getConfigDeviceId(null)); // to create sdk generated device id
        setupView_Event_Session();

        validateDeviceIdIsSdkGenerated();
        Assert.assertEquals(0, callCount.get());

        Countly.instance().deviceId().changeWithMerge("");
        Assert.assertEquals(0, callCount.get()); // validate callback not called
        validateBeganSessionRequest(); // also validates rq size is 1
    }

    /**
     * "changeWithMerge" multiple calls with same id
     * Validating that only two request added, one is session began, and other should be device id change request
     * and callback should be called only once
     * SDK must generate an id first, then should change with developer supplied. Second call must not change anything
     */
    @Test
    public void changeWithMerge_sameDeviceId() {
        AtomicInteger callCount = initDummyModuleForDeviceIdChangedCallback(new TestUtils.AtomicString(TestUtils.DEVICE_ID), false, DeviceIdType.DEVELOPER_SUPPLIED);
        Countly.instance().init(TestUtils.getConfigDeviceId(null)); // to create sdk generated device id
        setupView_Event_Session();
        validateBeganSessionRequest(); // also validates rq size is 1

        String oldDeviceId = Countly.instance().deviceId().getID();
        validateDeviceIdIsSdkGenerated();
        Assert.assertEquals(0, callCount.get());

        Countly.instance().deviceId().changeWithMerge(TestUtils.DEVICE_ID);
        Assert.assertEquals(1, callCount.get());
        validateDeviceIdWithMerge(oldDeviceId, 1, 2);

        Countly.instance().deviceId().changeWithMerge(TestUtils.DEVICE_ID);
        Assert.assertEquals(1, callCount.get());
        validateDeviceIdWithMerge(oldDeviceId, 1, 2);
    }

    /**
     * "getID", "getType"
     * Custom id is not given, validating that device id is sdk generated
     * Type must be 'SDK_GENERATED' and generated id should be a valid UUID
     */
    @Test
    public void getID_getType() {
        Countly.instance().init(TestUtils.getBaseConfig(null)); // no custom id given
        validateDeviceIdIsSdkGenerated(); // validate id is a valid UUID
    }

    /**
     * "getID", "getType"
     * Custom id is given, validating that device id is developer supplied
     * Type must be 'DEVELOPER_SUPPLIED' and generated id should be same with the given id
     */
    @Test
    public void getID_getType_customDeviceId() {
        Countly.instance().init(TestUtils.getBaseConfig(TestUtils.DEVICE_ID)); // custom id given
        validateDeviceIdDeveloperSupplied(TestUtils.DEVICE_ID);
    }

    /**
     * "logout"
     * Validating that all required requests are added, 2 began session, 1 end session, 1 events
     * uuid strategy generates a new id
     */
    @Test
    public void logout_sdkGenerated() {
        TestUtils.AtomicString deviceID = new TestUtils.AtomicString(TestUtils.DEVICE_ID);
        AtomicInteger callCount = initDummyModuleForDeviceIdChangedCallback(deviceID, true, DeviceIdType.SDK_GENERATED);
        Countly.instance().init(TestUtils.getConfigDeviceId(null)); // to create sdk generated device id
        setupView_Event_Session();

        validateDeviceIdIsSdkGenerated();
        Assert.assertEquals(0, callCount.get());
        String oldDeviceId = Countly.instance().deviceId().getID();

        Countly.instance().logout();
        Assert.assertEquals(1, callCount.get());
        validateDeviceIdWithoutMergeChange(4, oldDeviceId);
    }

    /**
     * "logout" with custom device id
     * Validating that no request added other than first began session request
     * custom strategy does not generate a new id because it is always same
     */
    @Test
    public void logout_developerSupplied() {
        TestUtils.AtomicString deviceID = new TestUtils.AtomicString(TestUtils.DEVICE_ID);
        AtomicInteger callCount = initDummyModuleForDeviceIdChangedCallback(deviceID, true, DeviceIdType.SDK_GENERATED);
        Countly.instance().init(TestUtils.getConfigDeviceId(TestUtils.DEVICE_ID)); // to create sdk generated device id
        setupView_Event_Session();

        validateDeviceIdDeveloperSupplied(TestUtils.DEVICE_ID);
        Assert.assertEquals(0, callCount.get());

        Countly.instance().logout();
        Assert.assertEquals(0, callCount.get()); // custom strategy only generates same id
        validateBeganSessionRequest();// only began request exist
    }

    /**
     * "acquireId"
     * Validating that acquired id is sdk generated and UUID
     * Acquired id must comply to UUID structure
     */
    @Test
    public void acquireId_sdkGenerated() {
        Countly.instance().init(TestUtils.getBaseConfig(null)); // no custom id provided
        validateDeviceIdIsSdkGenerated(); // validate id exist and sdk generated

        Config.DID did = SDKCore.instance.module(ModuleDeviceIdCore.class).acquireId();
        validateDeviceIdIsUUID(did.id);
    }

    /**
     * "acquireId"
     * Validating that acquired id is developer supplied
     * Acquired id must be same with the given id
     */
    @Test
    public void acquireId_customId() {
        Countly.instance().init(TestUtils.getBaseConfig(TestUtils.DEVICE_ID)); // custom id provided
        validateDeviceIdDeveloperSupplied(TestUtils.DEVICE_ID); // validate id exist and developer supplied

        Config.DID did = SDKCore.instance.module(ModuleDeviceIdCore.class).acquireId();
        Assert.assertEquals(TestUtils.DEVICE_ID, did.id);
    }

    private void validateDeviceIdWithoutMergeChange(final int rqSize, String oldDeviceId) {
        Map<String, String>[] requests = TestUtils.getCurrentRQ();
        Assert.assertEquals(rqSize, TestUtils.getCurrentRQ().length);

        AtomicInteger idx = new AtomicInteger();
        Arrays.stream(requests).forEach((request) -> {
            if (request.containsKey("begin_session") && idx.get() != 0) {
                //validate new begin session request
                TestUtils.validateRequiredParams(request, Countly.instance().deviceId().getID());
            } else {
                TestUtils.validateRequiredParams(request, oldDeviceId);
            }
            Assert.assertNull(request.get("old_device_id")); // in without merge this should not exist in all reqs
            idx.getAndIncrement();
        });
    }

    private void validateDeviceIdWithMerge(String oldDeviceId, final int rqIdx, final int rqSize) {
        Map<String, String>[] requests = TestUtils.getCurrentRQ();
        Assert.assertEquals(rqSize, TestUtils.getCurrentRQ().length);

        TestUtils.validateRequiredParams(requests[rqIdx], Countly.instance().deviceId().getID());
        Assert.assertEquals(oldDeviceId, requests[rqIdx].get("old_device_id"));
    }

    private AtomicInteger initDummyModuleForDeviceIdChangedCallback(TestUtils.AtomicString deviceId, boolean withoutMerge, DeviceIdType type) {
        AtomicInteger callCount = new AtomicInteger(0);
        SDKCore.testDummyModule = new ModuleBase() {
            @Override
            protected void deviceIdChanged(String oldDeviceId, boolean withMerge) {
                super.deviceIdChanged(oldDeviceId, withMerge);
                callCount.incrementAndGet();
                Assert.assertEquals(!withoutMerge, withMerge);
                if (type == DeviceIdType.SDK_GENERATED) {
                    validateDeviceIdIsSdkGenerated();
                } else {
                    validateDeviceIdDeveloperSupplied(deviceId.value);
                }
                Assert.assertEquals(type.index, internalConfig.getDeviceId().strategy);
            }
        };

        return callCount;
    }

    private void validateDeviceIdDeveloperSupplied(String expectedDeviceId) {
        Assert.assertEquals(expectedDeviceId, Countly.instance().deviceId().getID());
        Assert.assertEquals(DeviceIdType.DEVELOPER_SUPPLIED, Countly.instance().deviceId().getType());
    }

    private void validateDeviceIdIsSdkGenerated() {
        String deviceId = Countly.instance().deviceId().getID();
        Assert.assertTrue(deviceId.startsWith("CLY_"));
        try {
            validateDeviceIdIsUUID(deviceId);
            Assert.assertEquals(DeviceIdType.SDK_GENERATED, Countly.instance().deviceId().getType());
        } catch (IllegalArgumentException e) {
            Assert.fail("Device id is not a valid UUID");
        }
    }

    /**
     * Validates that the device id is a valid UUID and starts with "CLY_"
     */
    private void validateDeviceIdIsUUID(String deviceId) {
        try {
            String[] parts = deviceId.split("CLY_");
            UUID uuid = UUID.fromString(parts[1]);
            Assert.assertEquals(parts[1], uuid.toString());
        } catch (IllegalArgumentException e) {
            Assert.fail("Device id is not a valid UUID");
        }
    }

    private void validateBeganSessionRequest() {
        Map<String, String>[] requests = TestUtils.getCurrentRQ();
        Assert.assertEquals(1, requests.length); // always 1 because it is the first request
        TestUtils.validateRequiredParams(requests[0], Countly.instance().deviceId().getID());
    }

    /**
     * Creates a view, a session and an event to simulate what
     * happens when a device id change occurs
     */
    private void setupView_Event_Session() {
        Countly.session().begin();
        Countly.instance().events().startEvent(TestUtils.keysValues[0]);
        Countly.instance().view(TestUtils.keysValues[1]).start(true);
        Countly.instance().events().recordEvent(TestUtils.keysValues[2]);
    }
}
